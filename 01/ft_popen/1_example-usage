#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

// Assumes ft_popen is implemented and available
int ft_popen(const char *file, char *const argv[], char type);

// ==================================================
// EXAMPLE 1: BASIC READING - Use tool as data source
// ==================================================
void example1_basic_reading(void)
{
    printf("=== EXAMPLE 1: Reading from 'ls' command ===\n");
    
    // Launch 'ls' and connect to its stdout
    // Data flow: ls stdout → pipe → our read end
    int fd = ft_popen("ls", (char *const[]){"ls", "-l", NULL}, 'r');
    
    if (fd == -1) {
        perror("ft_popen failed");
        return;
    }
    
    // Read output from ls in chunks
    char buffer[256];
    ssize_t bytes_read;
    
    printf("Output from 'ls -l':\n");
    while ((bytes_read = read(fd, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[bytes_read] = '\0';  // Null terminate for printf
        printf("%s", buffer);
    }
    
    // CRITICAL: Close descriptor when done
    // This prevents resource leaks
    close(fd);
    printf("\n=== End of ls output ===\n\n");
}

// ==================================================
// EXAMPLE 2: BASIC WRITING - Feed data to tool
// ==================================================
void example2_basic_writing(void)
{
    printf("=== EXAMPLE 2: Writing to 'wc -l' command ===\n");
    
    // Launch 'wc -l' and connect to its stdin
    // Data flow: our write end → pipe → wc stdin
    int fd = ft_popen("wc", (char *const[]){"wc", "-l", NULL}, 'w');
    
    if (fd == -1) {
        perror("ft_popen failed");
        return;
    }
    
    // Send some lines to word count
    write(fd, "First line\n", 11);
    write(fd, "Second line\n", 12);
    write(fd, "Third line\n", 11);
    write(fd, "Fourth line\n", 12);
    
    // CRITICAL: Close write end to signal EOF to wc
    // Without this, wc would wait forever for more input
    close(fd);
    
    printf("Sent 4 lines to 'wc -l' - it should output '4'\n");
    printf("(Note: wc output goes directly to terminal)\n\n");
}

// ==================================================
// EXAMPLE 3: COMMAND CHAINING - Manual pipeline creation
// ==================================================
void example3_command_chaining(void)
{
    printf("=== EXAMPLE 3: Manual pipeline 'ls | grep .c' ===\n");
    
    // Step 1: Launch 'ls' and capture its output
    int ls_fd = ft_popen("ls", (char *const[]){"ls", NULL}, 'r');
    if (ls_fd == -1) {
        perror("ls ft_popen failed");
        return;
    }
    
    // Step 2: Redirect our stdin to ls output using dup2
    // This makes stdin read from ls instead of keyboard
    if (dup2(ls_fd, STDIN_FILENO) == -1) {
        perror("dup2 failed");
        close(ls_fd);
        return;
    }
    close(ls_fd);  // Original descriptor no longer needed
    
    // Step 3: Launch 'grep' which will read from our redirected stdin
    // Data flow: ls stdout → our stdin → grep stdin → grep stdout
    int grep_fd = ft_popen("grep", (char *const[]){"grep", "\\.c", NULL}, 'r');
    if (grep_fd == -1) {
        perror("grep ft_popen failed");
        return;
    }
    
    // Step 4: Read final results from grep
    char buffer[256];
    ssize_t bytes_read;
    
    printf("C files found:\n");
    while ((bytes_read = read(grep_fd, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[bytes_read] = '\0';
        printf("%s", buffer);
    }
    
    close(grep_fd);
    printf("=== End of pipeline ===\n\n");
}

// ==================================================
// EXAMPLE 4: DATA PROCESSING - Transform text through tool
// ==================================================
void example4_data_processing(void)
{
    printf("=== EXAMPLE 4: Text processing with 'tr' (translate) ===\n");
    
    // Launch 'tr' to convert lowercase to uppercase
    // tr 'a-z' 'A-Z' converts all lowercase letters to uppercase
    int fd = ft_popen("tr", (char *const[]){"tr", "a-z", "A-Z", NULL}, 'w');
    
    if (fd == -1) {
        perror("ft_popen failed");
        return;
    }
    
    // Send some text to be transformed
    const char *text = "hello world\nthis is a test\n";
    write(fd, text, strlen(text));
    
    // Close write end - tr will process and output to terminal
    close(fd);
    
    printf("Sent lowercase text to 'tr' for uppercase conversion\n");
    printf("(Transformed output appears directly on terminal)\n\n");
}

// ==================================================
// EXAMPLE 5: ERROR HANDLING - Robust usage pattern
// ==================================================
void example5_error_handling(void)
{
    printf("=== EXAMPLE 5: Robust error handling ===\n");
    
    // Try to launch a command that doesn't exist
    int fd = ft_popen("nonexistent_command", 
                      (char *const[]){"nonexistent_command", NULL}, 'r');
    
    if (fd == -1) {
        printf("✓ Correctly handled non-existent command\n");
    } else {
        printf("✗ Should have failed for non-existent command\n");
        close(fd);
    }
    
    // Try with valid command but monitor for read errors
    fd = ft_popen("echo", (char *const[]){"echo", "test message", NULL}, 'r');
    
    if (fd == -1) {
        perror("Unexpected failure with echo");
        return;
    }
    
    char buffer[100];
    ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);
    
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        printf("✓ Successfully read: %s", buffer);
    } else if (bytes_read == 0) {
        printf("✓ Reached EOF (command completed)\n");
    } else {
        perror("✗ Read error occurred");
    }
    
    close(fd);
    printf("\n");
}

// ==================================================
// EXAMPLE 6: BIDIRECTIONAL PATTERN - Read and Write Sequence
// ==================================================
void example6_bidirectional_pattern(void)
{
    printf("=== EXAMPLE 6: Sequential read/write operations ===\n");
    
    // First: Write data to sort command
    printf("Step 1: Sending unsorted data to 'sort'\n");
    int write_fd = ft_popen("sort", (char *const[]){"sort", NULL}, 'w');
    
    if (write_fd == -1) {
        perror("sort ft_popen failed");
        return;
    }
    
    // Send unsorted lines
    write(write_fd, "zebra\n", 6);
    write(write_fd, "apple\n", 6);
    write(write_fd, "banana\n", 7);
    write(write_fd, "cherry\n", 7);
    
    close(write_fd);  // Sort processes and outputs to terminal
    
    printf("Step 2: Reading system information\n");
    
    // Second: Read system information
    int read_fd = ft_popen("uname", (char *const[]){"uname", "-a", NULL}, 'r');
    
    if (read_fd == -1) {
        perror("uname ft_popen failed");
        return;
    }
    
    char buffer[256];
    ssize_t bytes_read = read(read_fd, buffer, sizeof(buffer) - 1);
    
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        printf("System info: %s", buffer);
    }
    
    close(read_fd);
    printf("\n");
}

// ==================================================
// MAIN FUNCTION - Run all examples
// ==================================================
int main(void)
{
    printf("ft_popen Comprehensive Examples\n");
    printf("================================\n\n");
    
    example1_basic_reading();
    example2_basic_writing();
    example3_command_chaining();
    example4_data_processing();
    example5_error_handling();
    example6_bidirectional_pattern();
    
    printf("All examples completed.\n");
    printf("\nKey takeaways:\n");
    printf("- 'r' mode: Read FROM command output\n");
    printf("- 'w' mode: Write TO command input\n");
    printf("- Always close() file descriptors\n");
    printf("- Check return values for errors\n");
    printf("- dup2() enables command chaining\n");
    
    return 0;
}