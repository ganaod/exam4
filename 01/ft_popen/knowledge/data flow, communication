COMMUNICATION TYPES:
'r': parent reads, child writes (child stdout → pipe → parent)
'w': parent writes, child reads (parent → pipe → child stdin)



  * COMMUNICATION DIAGRAM:
  * 
  * TYPE 'r' (read from command):
  * 
  * PARENT                    PIPE                    CHILD
  * ------                  ------                  ------
  *                     fds[0] ←------ fds[1]
  * read(fd) ←----------- |              | ←------ stdout
  *                      |              |         (command)
  * fd = fds[0]          |              |
  * close(fds[1])        |              |         close(fds[0])
  *                      |              |         close(fds[1])
  *                      |              |         dup2(fds[1], STDOUT)
  * 
  * TYPE 'w' (write to command):
  * 
  * PARENT                    PIPE                    CHILD  
  * ------                  ------                  ------
  *                     fds[0] ------→ fds[1]
  * write(fd) ----------→ |              | ------→ stdin
  *                      |              |         (command)
  * fd = fds[1]          |              |
  * close(fds[0])        |              |         close(fds[0])
  *                      |              |         close(fds[1])
  *                      |              |         dup2(fds[0], STDIN)






"Why close unused write end?" - This prevents DEADLOCK:
c// Dangerous scenario - DON'T do this:
if (type == 'r')
{
    // Parent wants to READ from child
    // If parent keeps write end open but never writes...
    // close(fds[1]);  // <-- If you comment this out
    return fds[0];
}
What happens:

Child is writing to pipe, then exits
Parent is reading from pipe
But pipe still has write end open (in parent process)
Pipe never signals EOF because a writer still exists
Parent blocks forever waiting for more data that never comes

The pipe rule: EOF only occurs when ALL write ends are closed.

Example
int fd = ft_popen("echo", (char*[]){"echo", "hello", NULL}, 'r');
char buffer[100];
read(fd, buffer, 100);  // Gets "hello\n"
read(fd, buffer, 100);  // Should get EOF (0 bytes)
                        // But if parent kept write end open, 
                        // this read() blocks FOREVER!









"Writing to a tool" = sending data to its stdin stream:
NOT writing to source code. Writing to the running program's input stream.
c// When you do this:
int fd = ft_popen("wc", (char*[]){"wc", "-l", NULL}, 'w');
write(fd, "hello\nworld\n", 12);

// You're sending "hello\nworld\n" to wc's stdin
// wc reads from stdin, processes the data, outputs "2" (line count)
// It's like typing "hello\nworld\n" into wc manually
Mental model: The tool program is running and waiting for input. You're feeding it data through its stdin pipe.