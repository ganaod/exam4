File Descriptor Closure Order
Analysis of this specific error case:
cif (pid == -1)  // fork failed
{
    close(fds[0]);  // Why this order?
    close(fds[1]);
    return -1;
}
Truth: The order is arbitrary here.
Logical reasoning:

Fork failed → no child process exists
Both descriptors reference the same pipe object in kernel
No data flow has been established yet
No dependencies between the two descriptors
Both must be closed to prevent leaks

Common patterns I observe:

Some code closes read-end first (fds[0] then fds[1])
Others close write-end first (fds[1] then fds[0])
Neither has a principled advantage in error cases

Where order DOES matter:

When processes are using the pipe (close write-end to signal EOF)
When one end is redirected (close after dup2, before exec)
In parent after successful fork (close unused end first)

My assessment: This particular ordering lacks principled justification. It could be fds[1] then fds[0] with identical correctness. The consistency within the codebase matters more than the specific order chosen.









The fork() Return Value Convention: First Principles Analysis
The Core Problem: After fork(), you have two identical processes executing the same code. How do they distinguish themselves?
Critical Constraint: The fork() system call can only return one value to each process.
Design Requirements Analysis:
Information Needs

Parent needs: Child's PID (for wait(), kill(), process management)
Child needs: Knowledge that it's the child (for branching logic)
Both need: Unambiguous identification mechanism

Why This Specific Convention?
Return 0 to child - Logical reasoning:

Child cannot receive its own PID (it doesn't know it yet when fork() returns)
0 is impossible as a real PID (PID 0 reserved for kernel scheduler)
Simple, unambiguous sentinel value
Enables clean if (pid == 0) branching

Return child's PID to parent - Logical reasoning:

Parent immediately needs child's PID for process coordination
Most useful information parent can receive
Enables immediate wait(pid), kill(pid, SIGTERM), etc.
No additional system call required to get child's PID

The Elegant Solution
cpid_t pid = fork();

if (pid == -1) {
    // Error: fork failed
    // Only one process, still original
}
else if (pid == 0) {
    // Child process
    // "I am the new process"
}  
else {
    // Parent process  
    // "I created process with PID = pid"
}
Why this is brilliant design:

Single syscall solves multiple problems: Process creation + identification + management handoff
No race conditions: Parent immediately knows child's PID before child even starts executing
Symmetric yet distinct: Both processes get exactly the information they need
Fail-secure: Error case (-1) is distinguishable from success cases
Enables immediate coordination: Parent can set up monitoring before child executes

Alternative Designs (and why they're inferior)
Alternative 1: Return same value to both

Problem: Processes can't distinguish themselves
Requires: Additional syscall like getppid() for branching logic

Alternative 2: Return child's PID to both

Problem: Child doesn't need its own PID immediately
Child still needs: Way to know it's the child

Alternative 3: Return 1 to child, child's PID to parent

Problem: 1 is a valid PID (init process), creates ambiguity
Better: 0 is impossible PID, cleaner logic

Process Identity Invariant
The deep principle: Each process needs exactly one bit of information to determine its role:

Parent: "Am I the original process?" → YES (received child's PID)
Child: "Am I the new process?" → YES (received 0)

This convention minimizes information transfer while maximizing coordination capability. The parent gets actionable data (child's PID), the child gets role identification (0 = child)